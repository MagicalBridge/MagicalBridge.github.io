(window.webpackJsonp=window.webpackJsonp||[]).push([[216],{608:function(t,e,r){"use strict";r.r(e);var a=r(14),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"剑指offer40-最小的k个数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#剑指offer40-最小的k个数"}},[t._v("#")]),t._v(" 剑指Offer40.最小的k个数")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/",target:"_blank",rel:"noopener noreferrer"}},[t._v("题目描述"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"解题思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("使用堆, 堆这种数据结构有一种典型的应用，优先队列。")]),t._v(" "),e("p",[t._v("普通队列：遵循先进先出、后进后出的原则\n优先队列：出队的顺序和入队的顺序无关，和优先级相关")]),t._v(" "),e("p",[t._v("问题抽象： 在N个元素中选出前M个元素")]),t._v(" "),e("p",[t._v("堆这种数据结构可以是一种树形结构，有两个特点：")]),t._v(" "),e("ul",[e("li",[t._v("堆中某个节点的值总是不大于其父亲节点的值")]),t._v(" "),e("li",[t._v("堆总是一颗完全二叉树 除了最后一层节点外，其他层的节点必须填满了。最后一层必须集中在最左侧。（最大堆）")])]),t._v(" "),e("p",[t._v("可以用数组存储二叉堆")]),t._v(" "),e("p",[t._v("我们可以使用一个大根堆实施维护数组的前k小的值，首先讲前k个数插入到大根堆中，随后从k+1个数开始遍历，如果当前遍历到的数比堆顶的数要小，就把堆顶数弹出再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。")])])}),[],!1,null,null,null);e.default=s.exports}}]);